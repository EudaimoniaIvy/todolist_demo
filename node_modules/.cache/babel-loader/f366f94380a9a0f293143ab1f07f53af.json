{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.regexp.flags.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.string.replace.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.json.stringify.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.object.keys.js\");\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Creates a new PubSubClass.\n * @class\n */\n\n\nvar PubSubClass = function () {\n  /**\n   * @constructs PubSubClass\n   */\n  function PubSubClass() {\n    _classCallCheck(this, PubSubClass);\n\n    this.channels = {};\n    this.flags = {\n      crossTabEnabled: false,\n      historyEnabled: false,\n      historyLength: 15\n    };\n    this.id = this._uuid();\n  }\n  /**\n    * Generate uuid.\n    * @function _uuid\n    * @returns {string} - returns new uuid\n   */\n\n\n  _createClass(PubSubClass, [{\n    key: '_uuid',\n    value: function _uuid() {\n      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = Math.random() * 16 | 0,\n            v = c == 'x' ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n      });\n    }\n    /**\n     * Write history to a channel\n     * @function _writeHistory\n     * @param {object} message - message to write\n     * @param {string} channel - the channel to write history to\n    */\n\n  }, {\n    key: '_writeHistory',\n    value: function _writeHistory(message, channel) {\n      // If history is enabled, store message in history.\n      if (this.flags.historyEnabled) {\n        this.channels[channel].history.push({\n          message: message,\n          time: Date.now()\n        });\n\n        if (this.channels[channel].history.length > this.flags.historyLength) {\n          this.channels[channel].history.shift();\n        }\n      }\n    }\n    /**\n      * Set flags\n      * @function setFlag\n     */\n\n  }, {\n    key: 'setFlag',\n    value: function setFlag(flag, value) {\n      switch (flag) {\n        case 'crossTabEnabled':\n          if (window) this.flags.crossTabEnabled = value;\n          break;\n\n        case 'historyEnabled':\n          this.flags.historyEnabled = value;\n          break;\n\n        case 'historyLength':\n          this.flags.historyLength = value;\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n      * Join a channel\n      * @function join\n      * @param {string} channel - the channel to join\n      * @param {function} handler - the function to send messages to.\n     */\n\n  }, {\n    key: 'join',\n    value: function join(channel, handler) {\n      var _this = this;\n\n      var uuid = this._uuid();\n\n      handler(false, uuid); // If the channel doesn't exist, create it.\n\n      if (!this.channels[channel]) {\n        this.channels[channel] = {\n          clients: {},\n          history: []\n        };\n      } // If cross tab is enabled, listen for cross tab messages\n\n\n      if (this.flags.crossTabEnabled) {\n        window.addEventListener('storage', function (e) {\n          if (e.key === 'PubSub-' + channel) {\n            var payload = JSON.parse(e.newValue);\n\n            if (payload.id != _this.id) {\n              handler(payload.message, uuid);\n\n              _this._writeHistory(payload.message, channel);\n            }\n          }\n        }, false);\n      } // Add our new client\n\n\n      this.channels[channel].clients[uuid] = handler;\n      return this;\n    }\n    /**\n      * Leave a channel\n      * @function leave\n      * @param {string} channel - the channel to leave\n      * @param {string} uuid - the uuid of the client who should leave\n      * @returns {promise} - returns new promise, resolved when client leaves\n     */\n\n  }, {\n    key: 'leave',\n    value: function leave(channel, uuid) {\n      var _this2 = this;\n\n      return new Promise(function (resolve) {\n        // Once we leave a channel, set our handler to a noop.\n        _this2.channels[channel].clients[uuid] = function () {\n          /*noop*/\n        };\n\n        resolve();\n      });\n    }\n    /**\n     * Get history from a channel\n     * @function history\n     * @param {string} channel - the channel to leave\n     * @param {number} limit - how many messages from history\n     * @returns {array} - returns history from channel\n    */\n\n  }, {\n    key: 'history',\n    value: function history(channel) {\n      var limit = arguments.length <= 1 || arguments[1] === undefined ? 15 : arguments[1];\n      return this.channels[channel].history.slice(0, limit);\n    }\n    /**\n      * Publish a message to channel\n      * @function publish\n      * @param {string} channel - the channel to publish to\n      * @param {object} message - the message to publish\n      * @returns {promise} - returns new promise, resolved when message is sent to all clients\n     */\n\n  }, {\n    key: 'publish',\n    value: function publish(channel, message) {\n      var _this3 = this; // If crossTab is enabled, dispatch message to app PubSub instances.\n\n\n      if (this.flags.crossTabEnabled) {\n        localStorage.setItem('PubSub-' + channel, JSON.stringify({\n          message: message,\n          time: Date.now(),\n          from: this.id\n        }));\n      }\n\n      this._writeHistory(message, channel);\n\n      return new Promise(function (resolve) {\n        // Send message to all subscribers.\n        Object.keys(_this3.channels[channel].clients).map(function (client, i) {\n          // Displatch message to client.\n          _this3.channels[channel].clients[client](message, client); // Once we're done, resole the promise letting us know.\n\n\n          if (Object.keys(_this3.channels[channel].clients).length - 1 === i) {\n            resolve();\n          }\n        });\n      });\n    }\n  }]);\n\n  return PubSubClass;\n}();\n\n; // Bind to global scope for easy access\n\nif (typeof global != 'undefined') {\n  global.PubSub = new PubSubClass();\n} else {\n  window.PubSub = new PubSubClass();\n}","map":{"version":3,"sources":["C:/Users/vae/Desktop/demo_todolist/node_modules/pubsub/dist.js"],"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","PubSubClass","channels","flags","crossTabEnabled","historyEnabled","historyLength","id","_uuid","value","replace","c","r","Math","random","v","toString","_writeHistory","message","channel","history","push","time","Date","now","shift","setFlag","flag","window","join","handler","_this","uuid","clients","addEventListener","e","payload","JSON","parse","newValue","leave","_this2","Promise","resolve","limit","arguments","undefined","slice","publish","_this3","localStorage","setItem","stringify","from","keys","map","client","global","PubSub"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAIA,YAAY,GAAG,YAAY;AAAE,WAASC,gBAAT,CAA0BC,MAA1B,EAAkCC,KAAlC,EAAyC;AAAE,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AAAE,UAAIE,UAAU,GAAGH,KAAK,CAACC,CAAD,CAAtB;AAA2BE,MAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AAAwDD,MAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AAAgC,UAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAA4BC,MAAAA,MAAM,CAACC,cAAP,CAAsBT,MAAtB,EAA8BI,UAAU,CAACM,GAAzC,EAA8CN,UAA9C;AAA4D;AAAE;;AAAC,SAAO,UAAUO,WAAV,EAAuBC,UAAvB,EAAmCC,WAAnC,EAAgD;AAAE,QAAID,UAAJ,EAAgBb,gBAAgB,CAACY,WAAW,CAACG,SAAb,EAAwBF,UAAxB,CAAhB;AAAqD,QAAIC,WAAJ,EAAiBd,gBAAgB,CAACY,WAAD,EAAcE,WAAd,CAAhB;AAA4C,WAAOF,WAAP;AAAqB,GAAhN;AAAmN,CAA9hB,EAAnB;;AAEA,SAASI,eAAT,CAAyBC,QAAzB,EAAmCL,WAAnC,EAAgD;AAAE,MAAI,EAAEK,QAAQ,YAAYL,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIM,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;AAEzJ;AACA;AACA;AACA;;;AAEA,IAAIC,WAAW,GAAG,YAAY;AAC5B;AACF;AACA;AAEE,WAASA,WAAT,GAAuB;AACrBH,IAAAA,eAAe,CAAC,IAAD,EAAOG,WAAP,CAAf;;AAEA,SAAKC,QAAL,GAAgB,EAAhB;AACA,SAAKC,KAAL,GAAa;AACXC,MAAAA,eAAe,EAAE,KADN;AAEXC,MAAAA,cAAc,EAAE,KAFL;AAGXC,MAAAA,aAAa,EAAE;AAHJ,KAAb;AAKA,SAAKC,EAAL,GAAU,KAAKC,KAAL,EAAV;AACD;AAED;AACF;AACA;AACA;AACA;;;AAGE3B,EAAAA,YAAY,CAACoB,WAAD,EAAc,CAAC;AACzBR,IAAAA,GAAG,EAAE,OADoB;AAEzBgB,IAAAA,KAAK,EAAE,SAASD,KAAT,GAAiB;AACtB,aAAO,uCAAuCE,OAAvC,CAA+C,OAA/C,EAAwD,UAAUC,CAAV,EAAa;AAC1E,YAAIC,CAAC,GAAGC,IAAI,CAACC,MAAL,KAAgB,EAAhB,GAAqB,CAA7B;AAAA,YACIC,CAAC,GAAGJ,CAAC,IAAI,GAAL,GAAWC,CAAX,GAAeA,CAAC,GAAG,GAAJ,GAAU,GADjC;AAEA,eAAOG,CAAC,CAACC,QAAF,CAAW,EAAX,CAAP;AACD,OAJM,CAAP;AAKD;AAED;AACJ;AACA;AACA;AACA;AACA;;AAf6B,GAAD,EAiBvB;AACDvB,IAAAA,GAAG,EAAE,eADJ;AAEDgB,IAAAA,KAAK,EAAE,SAASQ,aAAT,CAAuBC,OAAvB,EAAgCC,OAAhC,EAAyC;AAC9C;AACA,UAAI,KAAKhB,KAAL,CAAWE,cAAf,EAA+B;AAC7B,aAAKH,QAAL,CAAciB,OAAd,EAAuBC,OAAvB,CAA+BC,IAA/B,CAAoC;AAClCH,UAAAA,OAAO,EAAEA,OADyB;AAElCI,UAAAA,IAAI,EAAEC,IAAI,CAACC,GAAL;AAF4B,SAApC;;AAKA,YAAI,KAAKtB,QAAL,CAAciB,OAAd,EAAuBC,OAAvB,CAA+BlC,MAA/B,GAAwC,KAAKiB,KAAL,CAAWG,aAAvD,EAAsE;AACpE,eAAKJ,QAAL,CAAciB,OAAd,EAAuBC,OAAvB,CAA+BK,KAA/B;AACD;AACF;AACF;AAED;AACJ;AACA;AACA;;AAnBK,GAjBuB,EAsCvB;AACDhC,IAAAA,GAAG,EAAE,SADJ;AAEDgB,IAAAA,KAAK,EAAE,SAASiB,OAAT,CAAiBC,IAAjB,EAAuBlB,KAAvB,EAA8B;AACnC,cAAQkB,IAAR;AACE,aAAK,iBAAL;AACE,cAAIC,MAAJ,EAAY,KAAKzB,KAAL,CAAWC,eAAX,GAA6BK,KAA7B;AACZ;;AACF,aAAK,gBAAL;AACE,eAAKN,KAAL,CAAWE,cAAX,GAA4BI,KAA5B;AACA;;AACF,aAAK,eAAL;AACE,eAAKN,KAAL,CAAWG,aAAX,GAA2BG,KAA3B;AACA;;AACF;AACE;AAXJ;AAaD;AAED;AACJ;AACA;AACA;AACA;AACA;;AAvBK,GAtCuB,EA+DvB;AACDhB,IAAAA,GAAG,EAAE,MADJ;AAEDgB,IAAAA,KAAK,EAAE,SAASoB,IAAT,CAAcV,OAAd,EAAuBW,OAAvB,EAAgC;AACrC,UAAIC,KAAK,GAAG,IAAZ;;AAEA,UAAIC,IAAI,GAAG,KAAKxB,KAAL,EAAX;;AACAsB,MAAAA,OAAO,CAAC,KAAD,EAAQE,IAAR,CAAP,CAJqC,CAMrC;;AACA,UAAI,CAAC,KAAK9B,QAAL,CAAciB,OAAd,CAAL,EAA6B;AAC3B,aAAKjB,QAAL,CAAciB,OAAd,IAAyB;AACvBc,UAAAA,OAAO,EAAE,EADc;AAEvBb,UAAAA,OAAO,EAAE;AAFc,SAAzB;AAID,OAZoC,CAcrC;;;AACA,UAAI,KAAKjB,KAAL,CAAWC,eAAf,EAAgC;AAC9BwB,QAAAA,MAAM,CAACM,gBAAP,CAAwB,SAAxB,EAAmC,UAAUC,CAAV,EAAa;AAC9C,cAAIA,CAAC,CAAC1C,GAAF,KAAU,YAAY0B,OAA1B,EAAmC;AACjC,gBAAIiB,OAAO,GAAGC,IAAI,CAACC,KAAL,CAAWH,CAAC,CAACI,QAAb,CAAd;;AACA,gBAAIH,OAAO,CAAC7B,EAAR,IAAcwB,KAAK,CAACxB,EAAxB,EAA4B;AAC1BuB,cAAAA,OAAO,CAACM,OAAO,CAAClB,OAAT,EAAkBc,IAAlB,CAAP;;AACAD,cAAAA,KAAK,CAACd,aAAN,CAAoBmB,OAAO,CAAClB,OAA5B,EAAqCC,OAArC;AACD;AACF;AACF,SARD,EAQG,KARH;AASD,OAzBoC,CA2BrC;;;AACA,WAAKjB,QAAL,CAAciB,OAAd,EAAuBc,OAAvB,CAA+BD,IAA/B,IAAuCF,OAAvC;AAEA,aAAO,IAAP;AACD;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;AAzCK,GA/DuB,EA0GvB;AACDrC,IAAAA,GAAG,EAAE,OADJ;AAEDgB,IAAAA,KAAK,EAAE,SAAS+B,KAAT,CAAerB,OAAf,EAAwBa,IAAxB,EAA8B;AACnC,UAAIS,MAAM,GAAG,IAAb;;AAEA,aAAO,IAAIC,OAAJ,CAAY,UAAUC,OAAV,EAAmB;AACpC;AACAF,QAAAA,MAAM,CAACvC,QAAP,CAAgBiB,OAAhB,EAAyBc,OAAzB,CAAiCD,IAAjC,IAAyC,YAAY;AAAC;AAAS,SAA/D;;AACAW,QAAAA,OAAO;AACR,OAJM,CAAP;AAKD;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;AAlBK,GA1GuB,EA8HvB;AACDlD,IAAAA,GAAG,EAAE,SADJ;AAEDgB,IAAAA,KAAK,EAAE,SAASW,OAAT,CAAiBD,OAAjB,EAA0B;AAC/B,UAAIyB,KAAK,GAAGC,SAAS,CAAC3D,MAAV,IAAoB,CAApB,IAAyB2D,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAA1C,GAAsD,EAAtD,GAA2DD,SAAS,CAAC,CAAD,CAAhF;AAEA,aAAO,KAAK3C,QAAL,CAAciB,OAAd,EAAuBC,OAAvB,CAA+B2B,KAA/B,CAAqC,CAArC,EAAwCH,KAAxC,CAAP;AACD;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;AAdK,GA9HuB,EA8IvB;AACDnD,IAAAA,GAAG,EAAE,SADJ;AAEDgB,IAAAA,KAAK,EAAE,SAASuC,OAAT,CAAiB7B,OAAjB,EAA0BD,OAA1B,EAAmC;AACxC,UAAI+B,MAAM,GAAG,IAAb,CADwC,CAGxC;;;AACA,UAAI,KAAK9C,KAAL,CAAWC,eAAf,EAAgC;AAC9B8C,QAAAA,YAAY,CAACC,OAAb,CAAqB,YAAYhC,OAAjC,EAA0CkB,IAAI,CAACe,SAAL,CAAe;AACvDlC,UAAAA,OAAO,EAAEA,OAD8C;AAEvDI,UAAAA,IAAI,EAAEC,IAAI,CAACC,GAAL,EAFiD;AAGvD6B,UAAAA,IAAI,EAAE,KAAK9C;AAH4C,SAAf,CAA1C;AAKD;;AAED,WAAKU,aAAL,CAAmBC,OAAnB,EAA4BC,OAA5B;;AAEA,aAAO,IAAIuB,OAAJ,CAAY,UAAUC,OAAV,EAAmB;AACpC;AACApD,QAAAA,MAAM,CAAC+D,IAAP,CAAYL,MAAM,CAAC/C,QAAP,CAAgBiB,OAAhB,EAAyBc,OAArC,EAA8CsB,GAA9C,CAAkD,UAAUC,MAAV,EAAkBvE,CAAlB,EAAqB;AAErE;AACAgE,UAAAA,MAAM,CAAC/C,QAAP,CAAgBiB,OAAhB,EAAyBc,OAAzB,CAAiCuB,MAAjC,EAAyCtC,OAAzC,EAAkDsC,MAAlD,EAHqE,CAKrE;;;AACA,cAAIjE,MAAM,CAAC+D,IAAP,CAAYL,MAAM,CAAC/C,QAAP,CAAgBiB,OAAhB,EAAyBc,OAArC,EAA8C/C,MAA9C,GAAuD,CAAvD,KAA6DD,CAAjE,EAAoE;AAClE0D,YAAAA,OAAO;AACR;AACF,SATD;AAUD,OAZM,CAAP;AAaD;AA7BA,GA9IuB,CAAd,CAAZ;;AA8KA,SAAO1C,WAAP;AACD,CAvMiB,EAAlB;;AAyMA,C,CAEA;;AACA,IAAI,OAAOwD,MAAP,IAAiB,WAArB,EAAkC;AAChCA,EAAAA,MAAM,CAACC,MAAP,GAAgB,IAAIzD,WAAJ,EAAhB;AACD,CAFD,MAEO;AACL2B,EAAAA,MAAM,CAAC8B,MAAP,GAAgB,IAAIzD,WAAJ,EAAhB;AACD","sourcesContent":["'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Creates a new PubSubClass.\n * @class\n */\n\nvar PubSubClass = function () {\n  /**\n   * @constructs PubSubClass\n   */\n\n  function PubSubClass() {\n    _classCallCheck(this, PubSubClass);\n\n    this.channels = {};\n    this.flags = {\n      crossTabEnabled: false,\n      historyEnabled: false,\n      historyLength: 15\n    };\n    this.id = this._uuid();\n  }\n\n  /**\n    * Generate uuid.\n    * @function _uuid\n    * @returns {string} - returns new uuid\n   */\n\n\n  _createClass(PubSubClass, [{\n    key: '_uuid',\n    value: function _uuid() {\n      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = Math.random() * 16 | 0,\n            v = c == 'x' ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n      });\n    }\n\n    /**\n     * Write history to a channel\n     * @function _writeHistory\n     * @param {object} message - message to write\n     * @param {string} channel - the channel to write history to\n    */\n\n  }, {\n    key: '_writeHistory',\n    value: function _writeHistory(message, channel) {\n      // If history is enabled, store message in history.\n      if (this.flags.historyEnabled) {\n        this.channels[channel].history.push({\n          message: message,\n          time: Date.now()\n        });\n\n        if (this.channels[channel].history.length > this.flags.historyLength) {\n          this.channels[channel].history.shift();\n        }\n      }\n    }\n\n    /**\n      * Set flags\n      * @function setFlag\n     */\n\n  }, {\n    key: 'setFlag',\n    value: function setFlag(flag, value) {\n      switch (flag) {\n        case 'crossTabEnabled':\n          if (window) this.flags.crossTabEnabled = value;\n          break;\n        case 'historyEnabled':\n          this.flags.historyEnabled = value;\n          break;\n        case 'historyLength':\n          this.flags.historyLength = value;\n          break;\n        default:\n          break;\n      }\n    }\n\n    /**\n      * Join a channel\n      * @function join\n      * @param {string} channel - the channel to join\n      * @param {function} handler - the function to send messages to.\n     */\n\n  }, {\n    key: 'join',\n    value: function join(channel, handler) {\n      var _this = this;\n\n      var uuid = this._uuid();\n      handler(false, uuid);\n\n      // If the channel doesn't exist, create it.\n      if (!this.channels[channel]) {\n        this.channels[channel] = {\n          clients: {},\n          history: []\n        };\n      }\n\n      // If cross tab is enabled, listen for cross tab messages\n      if (this.flags.crossTabEnabled) {\n        window.addEventListener('storage', function (e) {\n          if (e.key === 'PubSub-' + channel) {\n            var payload = JSON.parse(e.newValue);\n            if (payload.id != _this.id) {\n              handler(payload.message, uuid);\n              _this._writeHistory(payload.message, channel);\n            }\n          }\n        }, false);\n      }\n\n      // Add our new client\n      this.channels[channel].clients[uuid] = handler;\n\n      return this;\n    }\n\n    /**\n      * Leave a channel\n      * @function leave\n      * @param {string} channel - the channel to leave\n      * @param {string} uuid - the uuid of the client who should leave\n      * @returns {promise} - returns new promise, resolved when client leaves\n     */\n\n  }, {\n    key: 'leave',\n    value: function leave(channel, uuid) {\n      var _this2 = this;\n\n      return new Promise(function (resolve) {\n        // Once we leave a channel, set our handler to a noop.\n        _this2.channels[channel].clients[uuid] = function () {/*noop*/};\n        resolve();\n      });\n    }\n\n    /**\n     * Get history from a channel\n     * @function history\n     * @param {string} channel - the channel to leave\n     * @param {number} limit - how many messages from history\n     * @returns {array} - returns history from channel\n    */\n\n  }, {\n    key: 'history',\n    value: function history(channel) {\n      var limit = arguments.length <= 1 || arguments[1] === undefined ? 15 : arguments[1];\n\n      return this.channels[channel].history.slice(0, limit);\n    }\n\n    /**\n      * Publish a message to channel\n      * @function publish\n      * @param {string} channel - the channel to publish to\n      * @param {object} message - the message to publish\n      * @returns {promise} - returns new promise, resolved when message is sent to all clients\n     */\n\n  }, {\n    key: 'publish',\n    value: function publish(channel, message) {\n      var _this3 = this;\n\n      // If crossTab is enabled, dispatch message to app PubSub instances.\n      if (this.flags.crossTabEnabled) {\n        localStorage.setItem('PubSub-' + channel, JSON.stringify({\n          message: message,\n          time: Date.now(),\n          from: this.id\n        }));\n      }\n\n      this._writeHistory(message, channel);\n\n      return new Promise(function (resolve) {\n        // Send message to all subscribers.\n        Object.keys(_this3.channels[channel].clients).map(function (client, i) {\n\n          // Displatch message to client.\n          _this3.channels[channel].clients[client](message, client);\n\n          // Once we're done, resole the promise letting us know.\n          if (Object.keys(_this3.channels[channel].clients).length - 1 === i) {\n            resolve();\n          }\n        });\n      });\n    }\n  }]);\n\n  return PubSubClass;\n}();\n\n;\n\n// Bind to global scope for easy access\nif (typeof global != 'undefined') {\n  global.PubSub = new PubSubClass();\n} else {\n  window.PubSub = new PubSubClass();\n}\n"]},"metadata":{},"sourceType":"script"}